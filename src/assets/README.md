
# osmium file extraction.

The initial nycmap.osm is generated by downloading a file via Overpass Turbo. nycmap is not
saved to source control because of its large size.

We then run:

```
osmium tags-filter src/assets/nycmap.osm "w/highway=*" -o nyc_roads_only.osm.pbf
```

to filter the output to only roads. Note that osmium cli needs to be installed. This is also not saved
to source control.


To do efficient query, we use Postgres + PostGIs extensions to help us figure out what
are the closest ways to a point. To do this, we

1. Install postgres/postgis
```
brew install postgresql
brew install postgis
brew install osm2pgsql
```

Thereafter, postgres can be started using:
```
brew run postgresql@14 # or follow whatever version
```

1. Bootstrap a new postgres db:

```
createdb osm_db
psql -d osm_db -c "CREATE EXTENSION postgis;" # enables the postgis extension
```
1. Load nyc_roads_only.osm.pbf into the postgres db.

```
osm2pgsql -c -d osm_db -H localhost -S /opt/homebrew/opt/osm2pgsql/share/osm2pgsql/default.style "$(pwd)/src/assets/nyc_roads_only.osm.pbf"
```

1. Create a new table to accomodate the basket location data
```
drop table if exists baskets;
create table baskets
(id integer, type char(5), lat double precision, lng double precision, geom geometry(POINT, 3857));

create unique index baskets_id_uniq on baskets(id);
create index baskets_geom_uniq on baskets using GIST(geom);

```

1. Load the points from inventory_clean.csv into postgres, transforming them from WGS 84(ESPG 4326), to a New York specific CRS.

```
\copy baskets(id,type,lat,lng) FROM './src/assets/inventory_clean.csv' DELIMITER ',' CSV HEADER

```

1. Do some data transformation on that data

```
update baskets b
set geom = (
  select st_transform(st_setsrid(st_makepoint(b1.lng, b1.lat), 4326), 3857)
  from baskets b1
  where b1.id = b.id
);

-- do a sanity check on the data should return 0 rows

with constants (epsilon) as (
  values(0.00000001)
)
select count(1) from baskets, constants 
where
abs(lat - st_y(st_transform(geom, 4326))) >= epsilon OR  -- here we check that the point created does not differ from whats in the csv
abs(lng - st_x(st_transform(geom, 4326))) >= epsilon
limit 10;
```

1. Use ST_Buffer, ST_Intersection, find the line segments that intersect the circles.


First lets do a sanity check
```
select st_dumppoints(st_buffer(geom, 80)) from baskets limit 1;

select 
	id, 
    array_to_json(array_agg(ARRAY[st_y(pt.geom), st_x(pt.geom)]))
from baskets b, st_dumppoints(st_transform(st_buffer(b.geom, 80), 4326)) pt
group by b.id
limit 1;
```


Now, find the line intersections
```
select 
    --st_astext(st_transform(b.geom, 4326))
    array_agg(st_astext(st_transform(st_intersection(l.way, pt), 4326)))
from 
    baskets b, 
    st_buffer(b.geom, 100) pt
inner join
    planet_osm_line l on st_intersects(l.way, pt)

where
1=1
and b.id = 10330153
and l.highway in ('residential', 'tertiary', 'secondary');
```

```
select 
--    json_build_object(
--      'type', 'FeatureCollection'
--      'features', json_agg(st_asgeojson(l.*))
--    )
json_agg(st_asgeojson(l.*))
from (
     select st_transform(way, 4326), highway 
     from planet_osm_line 
     where highway in ('residential', 'tertiary', 'secondary') 
    ) l
where
1=1
;
```


```
\copy (
  select 
    json_agg(st_asgeojson(l.*)::json)
  from (
     select st_transform(st_intersection(l.way, pt), 4326), highway 
     from baskets b, st_buffer(b.geom, 100) pt
     inner join planet_osm_line l on st_intersects(l.way, pt)
     where l.highway in ('residential', 'tertiary', 'secondary') 
     limit 10
    ) as l
  where
  1=1
) to './src/assets/matches.geojson'
```


1. Use ST_Union, ST_Touches, ST_Simplify to union and simplify line segments - we should get drastically less line segments.


1. Visualize line segments 

